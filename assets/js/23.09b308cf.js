(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{545:function(t,s,a){t.exports=a.p+"assets/img/fork.de6bb2cf.png"},599:function(t,s,a){"use strict";a.r(s);var n=a(8),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"fork-函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fork-函数"}},[t._v("#")]),t._v(" fork 函数")]),t._v(" "),n("ul",[n("li",[t._v("如果读者对进程不熟悉，请移步阅读进程相关系列文章")]),t._v(" "),n("li",[t._v("如果读者对linux 环境编译C语言代码不熟悉，请移步阅读相关文章")])]),t._v(" "),n("h3",{attrs:{id:"源代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源代码"}},[t._v("#")]),t._v(" 源代码")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<unistd.h>")])]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" cnt "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//派生进程")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pid_t")]),t._v(" pid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fork")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//派生失败")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fork error"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("exit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//派生成功返回值为0表示子进程")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\nchild: forkval=%d pid=%d cnt=%d\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pid"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getpid")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("cnt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//派生成功返回值大于0表示父进程，父进程中将返回子进程的PID。")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\nparent: forkval=%d pid=%d cnt=%d\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pid"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getpid")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cnt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        \n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("ul",[n("li",[t._v("注意，window环境下编译会失败，因为会提示不存在fork 函数，本次编译结果来源于linux 系统。")])]),t._v(" "),n("h3",{attrs:{id:"编译执行结果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编译执行结果"}},[t._v("#")]),t._v(" 编译执行结果")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[t._v("parent"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" forkval"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("71052")]),t._v(" pid"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("71051")]),t._v(" cnt"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\nchild"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" forkval"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" pid"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("71052")]),t._v(" cnt"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n")])])]),n("p",[t._v("fork函数用于创建一个与当前进程映像一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。")]),t._v(" "),n("p",[t._v("fork系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为task_struct的进程控制块PCB的结构。")]),t._v(" "),n("h3",{attrs:{id:"父子进程有什么区别呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#父子进程有什么区别呢"}},[t._v("#")]),t._v(" 父子进程有什么区别呢？")]),t._v(" "),n("ul",[n("li",[t._v("父进程设置了锁，子进程不继承。")]),t._v(" "),n("li",[t._v("进程ID各不相同")]),t._v(" "),n("li",[t._v("子进程的未决告警被清除")]),t._v(" "),n("li",[t._v("子进程的未决信号集设置未空集")])]),t._v(" "),n("h3",{attrs:{id:"函数原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数原型"}},[t._v("#")]),t._v(" 函数原型")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pid_t")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fork")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("pid_t是一个宏定义，其实质是int被定义在#include <sys/types.h>头文件中。")]),t._v(" "),n("h3",{attrs:{id:"返回值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[t._v("#")]),t._v(" 返回值")]),t._v(" "),n("ul",[n("li",[t._v("若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID，否则出错返回-1。\n"),n("img",{attrs:{src:a(545),alt:"avatar"}})])]),t._v(" "),n("h3",{attrs:{id:"进程标识符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#进程标识符"}},[t._v("#")]),t._v(" 进程标识符")]),t._v(" "),n("p",[t._v("每个进程都由独特换不相同的进程标识符（process ID），通过getpid()函数可获取当前进程的进程标识符，通过getppid()函数可获得父进程的进程标识符。")]),t._v(" "),n("h3",{attrs:{id:"概要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),n("p",[t._v("子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。值得注意的是子进程持有的是存储空间的副本，意味着父子进程之间是不会共享这些存储空间的。")]),t._v(" "),n("p",[t._v("UNIX将复制父进程的地址空间内容给子进程，因此子进程具有独立的地址空间。在不同的UNIX系统下，是无法确定fork后是子进程先运行还是父进程先运行，这依赖于系统的实现。")]),t._v(" "),n("h3",{attrs:{id:"fork执行执行流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fork执行执行流程"}},[t._v("#")]),t._v(" fork执行执行流程")]),t._v(" "),n("p",[t._v("当进程调用fork后控制转入内核，内核将会做4件事儿：")]),t._v(" "),n("ul",[n("li",[t._v("分配新的内存块和内核数据结构给子进程")]),t._v(" "),n("li",[t._v("将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程")]),t._v(" "),n("li",[t._v("添加子进程到系统进程列表中")]),t._v(" "),n("li",[t._v("fork返回开始调度器调度")])]),t._v(" "),n("h3",{attrs:{id:"为什么fork会返回两次呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么fork会返回两次呢"}},[t._v("#")]),t._v(" 为什么fork会返回两次呢？")]),t._v(" "),n("p",[t._v("因为复制时会复制父进程的堆栈段，所以两个进程都停留在fork函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。\n在父进程中将返回新建子进程的进程ID，\n在子进程中将返回0，\n若出现错误则返回一个负数，\n因此可以通过fork的返回值来判断当前进程是子进程还是父进程。")]),t._v(" "),n("h3",{attrs:{id:"为什么pid在父子进程中不同呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么pid在父子进程中不同呢"}},[t._v("#")]),t._v(" 为什么pid在父子进程中不同呢？")]),t._v(" "),n("p",[t._v("其实就相当于链表，进程形成了链表，父进程的pid指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的pid相当于链表中的指针。")]),t._v(" "),n("h3",{attrs:{id:"fork派生可能出现的错误原因是什么呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fork派生可能出现的错误原因是什么呢"}},[t._v("#")]),t._v(" fork派生可能出现的错误原因是什么呢？")]),t._v(" "),n("ul",[n("li",[t._v("当前进程数已经达到系统规定的上限错误值errno会被设置为EAGAIN。")])]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[t._v("$ cat "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("proc"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("sys"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("kernel"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("pid_max \n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("81920")]),t._v("\n")])])]),n("ul",[n("li",[t._v("系统内存不足时错误值errno会被设置为EAGAIN")])]),t._v(" "),n("h3",{attrs:{id:"fork系统调用使用注意"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fork系统调用使用注意"}},[t._v("#")]),t._v(" fork系统调用使用注意")]),t._v(" "),n("p",[t._v("fork系统调用之后父进程和子进程是交替执行，父子进程是处于不同空间中的\nfork系统调用的一次调用存在两次返回，此时二个进程处于独立的空间，各自执行自己的参数")])])}),[],!1,null,null,null);s.default=r.exports}}]);