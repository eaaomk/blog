(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{611:function(t,v,_){"use strict";_.r(v);var a=_(8),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"进程与线程的重要知识点问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程的重要知识点问题"}},[t._v("#")]),t._v(" 进程与线程的重要知识点问题")]),t._v(" "),_("ol",[_("li",[t._v("什么是前趋图?为什么要引入前趋图?")])]),t._v(" "),_("p",[t._v("前驱图(PrecedenceGraph)是一个有向无循环图，记为DAG(DirectedAcyclicGraph)，用于描述进程之间执行的前后关系。")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("试画出下面四条语句的前趋图:")])]),t._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[t._v("   S1"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("a"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("x"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("y"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   S2"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("b"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   S3"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("c"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("a"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("b"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   S4"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("w"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("c"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[t._v("此处暂时省略。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("为什么程序并发执行会产生间断性特征?")])]),t._v(" "),_("p",[t._v("程序在并发执行时，由于他们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。")]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("程序并发执行时为什么会失去封闭性和可再现性?")])]),t._v(" "),_("p",[t._v("程序并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变，致使程序运行失去了封闭性，也会导致其失去可再现性。")]),t._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[t._v("在操作系统中为什么要引入进程的概念?它会产生什么样的影响?")])]),t._v(" "),_("p",[t._v("为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程的概念。")]),t._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[t._v("试从动态性、并发性和独立性上比较进程和程序。")])]),t._v(" "),_("ul",[_("li",[t._v("动态性是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。")]),t._v(" "),_("li",[t._v("并发性是进程的重要特征，同时也是OS的重要特征。引入进程正是为了使其程序能和其他进程的程序并发执行，而程序是不能并发执行的。")]),t._v(" "),_("li",[t._v("独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源单位和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。")])]),t._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[t._v("试说明PCB的作用具体表现在哪几个方面,为什么说PCB是进程存在的唯一标志?")])]),t._v(" "),_("p",[t._v("PCB是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，成为能与其他进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。")]),t._v(" "),_("ol",{attrs:{start:"8"}},[_("li",[t._v("PCB提供了进程管理和进程调度所需要的哪些信息?")])]),t._v(" "),_("p",[t._v("进程管理；通用寄存器，指令计数器、程序状态字、用户栈指针进程调度“进程状态、进程优先级、事件、其他信息")]),t._v(" "),_("ol",{attrs:{start:"9"}},[_("li",[t._v("进程控制块的组织方式有哪几种?")])]),t._v(" "),_("p",[t._v("线性方式、链接方式、索引方式")]),t._v(" "),_("ol",{attrs:{start:"10"}},[_("li",[t._v("何谓操作系统内核?内核的主要功能是什么?")])]),t._v(" "),_("p",[t._v("现在操作系统一般将0S划分为若十层次，再将0S的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理、进程调度和许多模块所公用的一些基本操作)，都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的0S内核。")]),t._v(" "),_("p",[t._v("支撑功能：巾断处理、时钟管理、原语操作资源管理功能，进程管理、存储器管理、设备管理")]),t._v(" "),_("ol",{attrs:{start:"11"}},[_("li",[t._v("试说明进程在三个基本状态之间转换的典型原因.")])]),t._v(" "),_("ul",[_("li",[t._v("就绪状态一执行状态：进程分配到CPU资源")]),t._v(" "),_("li",[t._v("执行状态一就绪状态：时间片用完")]),t._v(" "),_("li",[t._v("执行状态一阻塞状态，I/0请求")]),t._v(" "),_("li",[t._v("阻塞状态一就绪状态：I/0完成")])]),t._v(" "),_("ol",{attrs:{start:"12"}},[_("li",[t._v("为什么要引入挂起状态?该状态有哪些性质?")])]),t._v(" "),_("p",[t._v("引入挂起状态处于五种不同的需要终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要，处于挂起状态的进程不能接收处理机调度。")]),t._v(" "),_("ol",{attrs:{start:"13"}},[_("li",[t._v("在进行进程切换时,所要保存的处理机状态信息有哪些?")])]),t._v(" "),_("p",[t._v("进行进程切换时，所要保存的处理机状态信息有：")]),t._v(" "),_("ul",[_("li",[t._v("进程当前暂存信息")]),t._v(" "),_("li",[t._v("下一指令地址儐息")]),t._v(" "),_("li",[t._v("进程状态信息")]),t._v(" "),_("li",[t._v("过程和系统调用参数及调用地址信息")])]),t._v(" "),_("ol",{attrs:{start:"14"}},[_("li",[t._v("试说明引起进程创建的主要事件.")])]),t._v(" "),_("p",[t._v("引起进程创建的主要事件有：用户登录、作业调度、提供服务、应用请求。")]),t._v(" "),_("ol",{attrs:{start:"15"}},[_("li",[t._v("试说明引起进程被撤消的主要事件.")])]),t._v(" "),_("p",[t._v("引起进程被撤销的主要事件有：正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、T/0故障)、外界干预（操作员或操作系统干预、父进程请求、父进程终止）。")]),t._v(" "),_("ol",{attrs:{start:"16"}},[_("li",[t._v("在创建一个进程时所要完成的主要工作是什么?")])]),t._v(" "),_("p",[t._v("(1)OS发现请求创建新进程事件后,调用进程创建原语Creat()\n(2)申请空白PCB;\n(3)为新进程分配资源;\n(4)初始化进程控制块;\n(5)将新进程插入就绪队列。")]),t._v(" "),_("ol",{attrs:{start:"17"}},[_("li",[t._v("在撒消一个进程时所要完成的主要工作是什么?")])]),t._v(" "),_("ul",[_("li",[t._v("(1)根据被终止进程标识符,从PCB集中检索出进程PCB,读出该进")]),t._v(" "),_("li",[t._v("(2) 岩被终止进程处于执行状态,立即终止该进程的执行,置调度标志真,指示该程被终止后重新调度。")]),t._v(" "),_("li",[t._v("(3) 若该进程还有子进程,应将所有子孙进程终止,以防它们成为不可控进程。")]),t._v(" "),_("li",[t._v("(4)将被终止进程拥有的全部资源,归还给父进程,或归还给系统。")]),t._v(" "),_("li",[t._v("(5)将被终止进程PCB从所在队列或列表中移出,等待其它程序搜集信息。")])]),t._v(" "),_("ol",{attrs:{start:"18"}},[_("li",[t._v("试说明引起进程阻塞或被唤醒的主要事件是什么?")])]),t._v(" "),_("p",[t._v("a.请求系统服务; b.启动某种操作: c.新数据尚未到达: d.无新工作可做")]),t._v(" "),_("ol",{attrs:{start:"19"}},[_("li",[t._v("为什么要在OS中引入线程?")])]),t._v(" "),_("p",[t._v("在操作系统中引入线程,则是为了减少程序在并发执行时所付出的时空开销,使OS具有更好的并发性,提高CPU的利用率。进程是分配资源的基本单位,而线程则是系统调度的基本单位。")]),t._v(" "),_("ol",{attrs:{start:"20"}},[_("li",[t._v("试说明线程具有哪些属性?")])]),t._v(" "),_("ul",[_("li",[t._v("(1)轻型实体")]),t._v(" "),_("li",[t._v("(2)独立调度和分派的基本单位")]),t._v(" "),_("li",[t._v("(3)可并发执行")]),t._v(" "),_("li",[t._v("(4)其享进程资源")])]),t._v(" "),_("ol",{attrs:{start:"21"}},[_("li",[t._v("试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。")])]),t._v(" "),_("ul",[_("li",[t._v("(1)调度性。线程在0S中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。")]),t._v(" "),_("li",[t._v("(2)并发性。进程可以并发执行，一个进程的多个线程也可并发执行。")]),t._v(" "),_("li",[t._v("(3)拥有资源。进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本身基本不拥有系统资源，但可以访问隶属进程的资源。")]),t._v(" "),_("li",[t._v("(4)系统开销。操作系统在创建、澈消和切换进程时付出的开销显著大于线程。")])]),t._v(" "),_("ol",{attrs:{start:"22"}},[_("li",[t._v("程控制块TCB中包含了哪些内容?")])]),t._v(" "),_("ul",[_("li",[t._v("线程标识符")]),t._v(" "),_("li",[t._v("一组寄存器")]),t._v(" "),_("li",[t._v("线程运行状态")]),t._v(" "),_("li",[t._v("优先级")]),t._v(" "),_("li",[t._v("线程专有存储区")]),t._v(" "),_("li",[t._v("信号屏蔽")]),t._v(" "),_("li",[t._v("堆栈指针")])]),t._v(" "),_("ol",{attrs:{start:"23"}},[_("li",[t._v("何谓用户级线程和内核支持线程?")])]),t._v(" "),_("ul",[_("li",[t._v("(1)用户级线程：仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、线程间的同步与通信等功能，都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。")]),t._v(" "),_("li",[t._v("(2)内核支持线程：在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、橄销和切换等都是依靠内核，在内核空问中实现的。在内核空问坦还为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。")])]),t._v(" "),_("ol",{attrs:{start:"24"}},[_("li",[t._v("试说明用户级线程的实现方法。")])]),t._v(" "),_("p",[t._v("用户级线程是在州户空问中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用丁管理和控制线程的函数的集合。内核控制线程或轻型进程L可通过系统调用获得内核提供服务，利用L进程作为中间系统。")]),t._v(" "),_("ol",{attrs:{start:"25"}},[_("li",[t._v("试说明内核支持线程的实现方法")])]),t._v(" "),_("p",[t._v("系统在创建新进程时，分配1个任务数据区FTDA,其中包括若干个线程控制块TCB空间。创建个线程分配一个TCB,有关信息与入TCB,为之分配必要的资源。当PTDA中的TCBH1完，而进程义有新线程时，只要所创建的线程数口未超过系统允许值，系统可在为之分配新的TCB:在做销一个线程时，也应回收线程的所有资源和TCB。")]),t._v(" "),_("ol",{attrs:{start:"26"}},[_("li",[t._v("多线程模型有哪几种类型?多对一模型有何优缺点?")])]),t._v(" "),_("p",[t._v("多对一模型、一对一模型利和多对多模型。\n多对一模型的主要缺点在于，如果一个线程在访问内核时发生阴塞，则整个进程都会被阻塞.此外，在任一时刻，只有一个线程能够访问内核。多个线程不能同时在多个处理机上运行。")])])}),[],!1,null,null,null);v.default=s.exports}}]);